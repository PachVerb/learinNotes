ApI:
	DOM：文档对象模型，他是HTML或者XML文档的编程接口，对文档进行结构化解释，dom结构树（DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合）。
	可以通过编程语言访问该文档结构。从而改变该文档的结构，内容，样式。简言之，它将web页面和脚本或程序语言连接起来。

API (web 或 XML 页面) = DOM + JS (脚本语言)？

js内置函数语言并不是js代码编写，而是像c++低级语言编写/

内置浏览器函数并不是函数――它们是方法。即是内置对象方法不是函数

console(
1.他能看到结构话的东西，如果是alert，淡出一个对象就是[object object],但是console能看到对象的内容。

2.console不会打断你页面的操作，如果用alert弹出来内容，那么页面就死了，但是console输出内容后你页面还可以正常操作。
)

函数理解成L,R查询不合适。

console内置对象。

发生作用域嵌套，如果当前作用域找不到变量，那就会在上级作用域查找，或者最外层作用域，即使全局作用域，并且查找过程会停止。

LHS AND RHS引用举例理解：

	console.log(a);这里对a的引用是一个RHS引用，因为这里a并没有赋予任何值，我们只是想查找并取得a的值，然后将它打印出来。

	a = 2; 这里对a的引用是一个LHS引用，因为我们并不关心当前的值是什么，只是想要为赋值操作找到目标。

	总结：凡是对变量值的操作，都是RHS引用；对变量赋值操作则是LHS

 Maximum call stack size exceeded异常；
	1.递归；
	2.冲入js库

---------------------------------------------------- 

	js具有基于函数的作用域，每申明函数会创建作用域。

	var 不会创建作用域・ 用let const会形成块级作用域，也就是{}内会形成。

j	s之前只会有函数作用域，一个函数作用域。let const申明的只要在{}就会直接形成块级作用域。

arguments对象中有一个非常有用的属性：callee。arguments.callee返回此arguments对象所在的当前函数引用。
在使用函数递归调用时推荐使用arguments.callee代替函数名本身。

callee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。
这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也称为“匿名函数”)内。


全局变量（Global）和window 对象

一旦数据不再有用，最好通过将其值设置为 null 来释放其引用。这个方法叫做解除引用。
这一做法适用于大多数的全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。


闭包：应用场景，函数当作参数传递或者传递函数（以函数作为返回值）

javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况――全局代码，函数体，eval代码。
代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。
使用闭包会增加内容开销，

代码执行前生成全局上下文，  f并对变量赋值。
这样可以理解，函数或者变量在引用之前都是undefinded;

content指的是 函数被调用的时候, 查看this指向哪个object, 那么那个object 就是当前的 "上下文"。
这里面还有个问题：构建执行环境作用域时，arguments对象（隐藏对象，不可见），函数，参数,变量的声明与构建有先后顺序。
arguments对象（隐藏对象，不可见）―>函数―>参数―>变量
========================================================

AJAX:异步js和xml
 作用：无需重新加载正个网页实现网页更新

http:无状态协议，于web服务器是一个无记忆请求过程。

http请求流程：
	1.建立TCP连接
	2.web浏览器像web服务器发送请求命令
	3.web浏览器向服务器发送请求头信息
	4.等待web服务器应答
	5.web服务器回应头信息
	6.web服务器发送数据
	7.web服务器关闭TCP连接
http请求四部分：
	1.请求方式：get or post
		get:一般用于信息获取，使用URL传递参数，对所发信息数量有限制，（~2000字符）
		post:修改服务器上的资源，对发送信息数量无限制。
	2.请求地址：url
	3.请求头：包括客户端环境以及用户身份信息
	4.请求体：用户提交的一些字符信息，表单信息。