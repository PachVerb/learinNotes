# 模块(静态分析)
- 通用模块
- 异步模块

## 'use strict' rules
>严格模式主要有以下限制。
>变量必须声明后再使用
>函数的参数不能有同名属性，否则报错
>不能使用with语句
>不能对只读属性赋值，否则报错
>不能使用前缀 0 表示八进制数，否则报错
>不能删除不可删除的属性，否则报错
>不能删除变量delete prop，会报错，只能删除属性delete global[prop]
>eval不会在它的外层作用域引入变量
>eval和arguments不能被重新赋值
>arguments不会自动反映函数参数的变化
>不能使用arguments.callee
>不能使用arguments.caller
>禁止this指向全局对象
>不能使用fn.caller和fn.arguments获取函数调用的堆栈
>增加了保留字（比如protected、static和interface）


export 是对外暴露的接口， 因该和内部变量建立一一对应关系。

export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。import命令是编译阶段执行的，在代码运行之前。

> 多次执行一个模块，或者以不同接口名对同一个模块导入，结果只有一个生效。

>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。

# export default name-variable
本质上，export default就是输出一个叫做default的变量或方法


不推荐一个模块，多个API,一个模块导出全部。 推荐一个接口一个导出。
便于引擎性能优化。

模块只有一个导出时，导入语句，可以省略 { 。。 }


> import 'foo' 这样导入一个模块，时模块机制的基本形式。但作用不大，可以用来实现一些模块的预加载。

# 命名空间导入

# 模块加载
> 通过脚本外部提供的模块加载器，将模块标识符解析为url。查找依赖的模块。

## 模块外加载模块。
> 直接与模块加载器交互
动态的模块加载
在非模块内加载模块，特别时浏览器加载脚本需要使用模块加载时。
自定义加载

